---
id: update-ko-KR
title: 불변성 헬퍼들
permalink: update-ko-KR.html
prev: clone-with-props-ko-KR.html
next: pure-render-mixin-ko-KR.html
---

React는 데이터 관리 방식이 무엇이든간에 사용할 수 있게 해줍니다. 변화 마저도요. 하지만 만약 변할수 없는 데이터를 애플리케이션에서 성능이 중요한 부분에서 사용할 수 있다면, 애플리케이션의 속도를 크게 향상시킬 `shouldComponentUpdate()` 메서드를 구현하기 쉽게 됩니다.

JavaScript에서 변할 수 없는 데이터를 다루는것은 [Clojure](http://clojure.org/)처럼 그것을 위해 디자인된 언어보다 어렵습니다. 하지만, React는 간단한 불변성 헬퍼를 제공합니다. `update()`는 이런 종류의 데이터를 근본적인 변화 *없이*  쉽게 다루도록 해줍니다.

## 주요 아이디어

만약 데이터를 이렇게 변화시킨다면:

```js
myData.x.y.z = 7;
// or...
myData.a.b.push(9);
```

이전의 카피가 덮어씌워진다면 어떤 자료가 바뀌었는지 알 방도가 없습니다. 대신에, `myData`의 새로운 카피를 만들고 오직 변화가 필요한 부분만 바꿀 필요가 있습니다. 그 다음 `shouldComponentUpdate()` 에서  `myData`의 이전 카피와 새로운 카피를 === 연산자를 사용하여 비교할 수 있습니다. 

```js
var newData = deepCopy(myData);
newData.x.y.z = 7;
newData.a.b.push(9);
```

하지만 깊은 복사는 비싸고, 가끔은 불가능하기도 합니다. 변화가 필요한 객체만 복제하고, 변화 없는 객체를 다시 사용함으로써 완화를 시킬수는 있습니다. 안타깝지만 오늘날의 JavaScript에서는 성가실 수 있습니다:

```js
var newData = extend(myData, {
  x: extend(myData.x, {
    y: extend(myData.x.y, {z: 7}),
  }),
  a: extend(myData.a, {b: myData.a.b.concat(9)})
});
```

이게 꽤 성능 기준에 맞는 반면에 (`log n`개의 객체만 얕은 복사하고, 나머지는 재사용하기 때문), 쓰기엔 큰 고통이 따릅니다. 이 반복들을 보세요! 이건 짜증날 뿐만 아니라 버그들을 야기할수도 있습니다.

`update()`는 이런 패턴 속에서 코드를 더 쉽게 쓸 수 있도록 구문적 꿀을 제공합니다. 코드는 이렇게 됩니다:

```js
var newData = React.addons.update(myData, {
  x: {y: {z: {$set: 7}}},
  a: {b: {$push: [9]}}
});
```

문법에 익숙해지기에는 시간이 조금 걸리지만 ([MongoDB 쿼리 언어](http://docs.mongodb.org/manual/core/crud-introduction/#query)에서 영감을 받아), 쓸모 없는 반복이 없고 정적분석이 가능할 뿐더러 변할 수 있는 버전보다 더 많은 타이핑이 필요하지도 않습니다.


`$`가 앞에 붙어있는 키들은 *커맨드* 라고 불립니다. "변하는" 자료 구조는 *타겟* 이라고 불립니다.

## 사용가능한 커맨드들

  * `{$push: array}` `push()` all the items in `array` on the target.
  * `{$unshift: array}` `unshift()` all the items in `array` on the target.
  * `{$splice: array of arrays}` for each item in `arrays` call `splice()` on the target with the parameters provided by the item.
  * `{$set: any}` replace the target entirely.
  * `{$merge: object}` merge the keys of `object` with the target.
  * `{$apply: function}` passes in the current value to the function and updates it with the new returned value.

## 예제 

### 간단한 push

```js
var initialArray = [1, 2, 3];
var newArray = update(initialArray, {$push: [4]}); // => [1, 2, 3, 4]
```
`initialArray` is still `[1, 2, 3]`.

### 중첩된 컬렉션

```js
var collection = [1, 2, {a: [12, 17, 15]}];
var newCollection = update(collection, {2: {a: {$splice: [[1, 1, 13, 14]]}}});
// => [1, 2, {a: [12, 13, 14, 15]}]
```
This accesses `collection`'s index `2`, key `a`, and does a splice of one item starting from index `1` (to remove `17`) while inserting `13` and `14`.

### 현재 상태에 의거해 값을 업데이트

```js
var obj = {a: 5, b: 3};
var newObj = update(obj, {b: {$apply: function(x) {return x * 2;}}});
// => {a: 5, b: 6}
// This is equivalent, but gets verbose for deeply nested collections:
var newObj2 = update(obj, {b: {$set: obj.b * 2}});
```

### (얕은) 합병 

```js
var obj = {a: 5, b: 3};
var newObj = update(obj, {$merge: {b: 6, c: 7}}); // => {a: 5, b: 6, c: 7}
```
